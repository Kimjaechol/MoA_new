# 특허출원서

---

## [발명의 명칭]

**서버 비저장 방식의 다중 기기 간 종단간 암호화 메모리 동기화 시스템 및 방법**

System and Method for End-to-End Encrypted Memory Synchronization Between Multiple Devices Without Persistent Server Storage

---

## [기술분야]

본 발명은 복수의 사용자 기기 간에 장기기억 데이터를 동기화하는 기술에 관한 것으로, 보다 구체적으로는 서버에 사용자 데이터를 영구적으로 저장하지 않으면서도 기기 간 실시간 동기화, 오프라인 기기에 대한 사후 동기화, 및 장기 오프라인 기기에 대한 수동 전체 동기화를 종단간 암호화 환경에서 안정적으로 수행하는 시스템 및 방법에 관한 것이다.

---

## [배경기술]

### 종래 기술의 문제점

현재 복수 기기 간 데이터 동기화 기술은 크게 두 가지 방식으로 분류된다.

**제1 방식: 클라우드 중앙 저장 방식**

Apple iCloud, Google Drive 등으로 대표되는 클라우드 동기화 방식은 사용자 데이터를 중앙 서버에 영구적으로 저장하고, 각 기기가 서버로부터 데이터를 다운로드하는 구조이다. 이 방식은 동기화의 안정성이 높으나, 다음과 같은 근본적 문제를 가진다.

첫째, 서버 운영자가 사용자 데이터에 접근할 수 있어 프라이버시 침해 위험이 존재한다. 종단간 암호화를 적용하더라도 서버에 암호화된 데이터가 영구적으로 보관되므로, 암호화 키의 유출 또는 미래의 암호 해독 기술 발전에 의한 데이터 노출 위험이 상존한다.

둘째, 서버 저장 비용이 사용자 수 및 데이터 양에 비례하여 지속적으로 증가한다.

셋째, 서버 장애 시 모든 기기의 동기화가 중단되는 단일 장애점(Single Point of Failure) 문제가 있다.

**제2 방식: P2P 직접 동기화 방식**

Syncthing 등으로 대표되는 P2P 동기화 방식은 기기 간 직접 데이터를 전송하여 서버 의존도를 줄인다. 그러나 이 방식은 다음과 같은 한계를 가진다.

첫째, 두 기기가 동시에 온라인 상태여야 동기화가 가능하다. 사용자가 기기 A에서 작업한 후 기기 A를 종료하고, 나중에 기기 B를 켜면 동기화가 불가능하다.

둘째, NAT 통과(NAT traversal) 문제로 인해 네트워크 환경에 따라 기기 간 직접 연결이 불가능한 경우가 빈번하다.

셋째, 대화형 AI의 장기기억(long-term memory)과 같이 지속적으로 축적되는 데이터의 경우, 동기화 누락이 AI 서비스의 품질 저하로 직결되어 높은 신뢰성이 요구된다.

**종래 기술의 미해결 과제**

따라서 (1) 서버에 사용자 데이터를 영구 저장하지 않아 프라이버시를 보장하면서도, (2) 기기가 동시에 온라인이 아닌 상황에서도 안정적인 동기화를 수행하고, (3) 데이터의 전송 순서 보장 및 누락 방지를 달성하며, (4) 장기간 오프라인이었던 기기에 대해서도 완전한 데이터 일관성을 복원할 수 있는 기술이 요구되고 있다.

---

## [발명의 내용]

### [해결하고자 하는 과제]

본 발명은 상기한 종래 기술의 문제점을 해결하기 위한 것으로, 다음의 과제를 해결하는 것을 목적으로 한다.

제1 과제는, 서버에 사용자 데이터를 영구적으로 저장하지 않으면서도 비동시 온라인 상태의 복수 기기 간 데이터 동기화를 가능하게 하는 것이다.

제2 과제는, 네트워크 지연 및 전송 순서 역전 상황에서도 데이터의 올바른 순서를 보장하는 것이다.

제3 과제는, 수신 기기의 일시적 오프라인으로 인한 데이터 누락을 방지하되, 서버 저장 없이 이를 달성하는 것이다.

제4 과제는, 장기간(소정의 보관 기간을 초과하여) 오프라인이었던 기기에 대해서도 수동 개입을 통해 완전한 데이터 일관성을 복원할 수 있게 하는 것이다.

제5 과제는, 상기 모든 과정에서 종단간 암호화를 유지하여 서버 및 네트워크 중간자가 평문 데이터에 접근할 수 없도록 하는 것이다.

### [과제의 해결 수단]

상기 과제를 해결하기 위하여 본 발명은 다음의 구성을 포함하는 **3단계 계층적 동기화 시스템**을 제공한다.

#### 제1 구성: 임시 릴레이 기반 실시간 동기화 (제1 계층)

본 발명의 제1 계층은, 서버를 데이터의 일시적인 중계점(릴레이)으로만 활용하는 임시 릴레이 동기화 방식을 포함한다.

송신 기기는 동기화 대상 데이터를 종단간 암호화한 후, 소정의 유효기간(TTL; Time To Live)을 부여하여 서버에 업로드한다. 서버는 상기 유효기간이 경과한 데이터를 자동으로 삭제한다. 서버는 실시간 통신 채널(WebSocket 기반 실시간 브로드캐스트)을 통하여 수신 기기에 데이터 도착을 즉시 통지하고, 수신 기기는 유효기간 내에 데이터를 다운로드하여 복호화한다.

상기 구성에 의하여, 수신 기기가 온라인 상태인 경우 실시간에 가까운 동기화가 달성되며, 유효기간 경과 후 서버에는 사용자 데이터가 잔존하지 않는다.

#### 제2 구성: 로컬 델타 저널 기반 사후 재동기화 (제2 계층)

상기 제1 계층은 수신 기기가 유효기간 내에 온라인 상태가 아닌 경우 데이터 누락이 발생하는 문제를 가진다. 본 발명의 제2 계층은 이 문제를 해결하기 위한 로컬 델타 저널(Local Delta Journal) 기반 사후 재동기화 방식을 포함한다.

##### 제2-1 구성: 시퀀스 넘버 및 버전 벡터

각 기기는 자신이 생성하는 각 데이터 변경 단위(이하 "델타"라 함)에 대하여 단조 증가하는 시퀀스 넘버(sequence number)를 부여한다. 상기 시퀀스 넘버는 기기 식별자와 결합되어 (기기 식별자, 시퀀스 넘버) 쌍으로 각 델타를 전역적으로 고유하게 식별한다.

각 기기는 버전 벡터(Version Vector)를 유지한다. 상기 버전 벡터는 {기기 식별자 → 해당 기기로부터 마지막으로 수신한 시퀀스 넘버}의 매핑 구조를 가지며, 각 기기가 다른 모든 기기의 데이터를 어디까지 수신하였는지를 추적한다.

##### 제2-2 구성: 로컬 델타 저널

각 기기는 자신이 생성한 델타를 소정의 보관 기간(예: 30일) 동안 로컬 저장소에 보관하는 델타 저널을 유지한다. 상기 델타 저널은 서버가 아닌 기기의 로컬 저장소에만 보관되며, 암호화된 상태의 데이터를 포함한다.

상기 보관 기간이 경과한 델타는 저널에서 자동으로 삭제(pruning)되어 로컬 저장 공간을 절약한다.

##### 제2-3 구성: 순서 보장 메커니즘

수신 기기는 수신한 델타의 시퀀스 넘버를 검사하여, 기대 시퀀스(버전 벡터의 마지막 수신 시퀀스 + 1)와 일치하는 경우에만 즉시 적용한다.

기대 시퀀스보다 큰 시퀀스의 델타가 수신된 경우(즉, 갭이 발생한 경우), 해당 델타를 순서 대기 버퍼(Order Buffer)에 임시 보관하고, 누락된 시퀀스의 델타를 재전송 요청한다.

기대 시퀀스 이하의 시퀀스를 가진 델타가 수신된 경우, 이미 수신 완료된 중복 데이터로 판단하여 무시한다(멱등성 보장).

순서 대기 버퍼에 연속된 시퀀스의 델타가 축적되면, 일괄적으로 시퀀스 순서대로 적용한다(버퍼 플러시).

##### 제2-4 구성: 재연결 시 자동 재동기화 프로토콜

오프라인이었던 기기가 온라인으로 복귀하면, 데이터베이스 저장을 수반하지 않는 실시간 브로드캐스트 채널(WebSocket 브로드캐스트)을 통하여 자신의 버전 벡터를 포함한 동기화 요청(sync_request) 메시지를 브로드캐스트한다.

상기 동기화 요청을 수신한 온라인 기기는, 요청 기기의 버전 벡터와 자신의 로컬 델타 저널을 비교하여, 요청 기기가 수신하지 못한 델타를 식별한다. 식별된 누락 델타를 상기 브로드캐스트 채널을 통하여 재전송한다.

상기 브로드캐스트 채널은 순수 WebSocket 메시지 전달만을 수행하며, 메시지 내용이 서버의 데이터베이스에 저장되지 않는다. 이에 의하여 재동기화 과정에서도 서버에 사용자 데이터가 보관되지 않는다.

요청 기기는 재전송 수신 완료 후 수신 확인(ACK) 메시지를 발신하여, 양측의 버전 벡터를 일치시킨다.

##### 제2-5 구성: 상태 영속화 및 복원

각 기기는 애플리케이션 종료 시 현재의 시퀀스 넘버, 버전 벡터, 및 델타 저널을 로컬 영속 저장소(예: AsyncStorage, localStorage, SQLite)에 저장한다.

애플리케이션 재시작 시 상기 저장된 상태를 복원하여, 애플리케이션 재시작 전후의 동기화 연속성을 보장한다.

#### 제3 구성: 매니페스트 비교 기반 수동 전체 동기화 (제3 계층)

상기 제2 계층의 로컬 델타 저널은 소정의 보관 기간(예: 30일)이 경과하면 자동 삭제되므로, 보관 기간을 초과하여 오프라인이었던 기기에 대해서는 제2 계층의 사후 재동기화가 불가능하다. 본 발명의 제3 계층은 이러한 경우를 위한 수동 전체 동기화 방식을 포함한다.

##### 제3-1 구성: 매니페스트 생성 및 교환

사용자가 수동 동기화를 요청하면, 요청 기기는 자신이 보유한 모든 엔티티(장기기억 청크, 대화 세션, 설정 등)의 식별자 목록인 매니페스트(Manifest)를 생성한다.

상기 매니페스트를 브로드캐스트 채널을 통하여 전체 동기화 요청(full_sync_request) 메시지로 전송한다.

상기 요청을 수신한 온라인 기기는 자신의 매니페스트를 생성하여 응답한다.

##### 제3-2 구성: 양방향 차분 비교 및 선택적 전송

양측 기기는 수신한 상대 매니페스트와 자신의 매니페스트를 비교하여, 각각이 보유하고 상대방에게 누락된 엔티티를 식별한다.

상기 비교는 엔티티 식별자의 집합 차(set difference) 연산으로 수행되며, 기존 데이터의 재전송 없이 누락된 엔티티만을 선택적으로 전송한다.

전송은 엔티티 단위로 종단간 암호화된 상태에서 브로드캐스트 채널을 통하여 수행된다.

##### 제3-3 구성: 진행 상황 추적 및 완료 처리

수신 기기는 수신한 엔티티 수를 추적하며, 사용자에게 진행 상황(비교 중, 수신 중, 전송 중, 완료)을 표시한다.

전송 측 기기는 모든 누락 엔티티의 전송을 완료한 후 완료 알림(full_sync_complete) 메시지를 발신한다.

소정의 시간(예: 60초) 내에 응답이 없는 경우, 상대 기기가 오프라인 상태인 것으로 판단하여 타임아웃 처리한다.

#### 제4 구성: 종단간 암호화

상기 제1 내지 제3 구성의 모든 데이터 전송에 있어서, 데이터는 송신 기기에서 AES-256-GCM 알고리즘으로 암호화되고, 수신 기기에서만 복호화된다.

암호화 키는 사용자가 설정한 패스프레이즈(passphrase)로부터 PBKDF2 키 유도 함수를 통하여 파생되며, 서버에는 전송되지 않는다.

각 암호화 작업에는 고유한 초기화 벡터(IV)와 인증 태그(Auth Tag)가 사용되어, 동일한 평문에 대해서도 서로 다른 암호문이 생성된다.

서버는 모든 과정에서 암호화된 데이터만을 중계하며, 평문 데이터에 접근할 수 없다.

### [발명의 효과]

본 발명에 의하면 다음의 효과가 달성된다.

**제1 효과 (프라이버시 보장):** 서버에 사용자 데이터가 영구적으로 저장되지 않는다. 임시 릴레이 데이터는 소정의 유효기간 후 자동 삭제되고, 재동기화 및 수동 동기화 과정은 데이터베이스 저장을 수반하지 않는 브로드캐스트 채널만을 사용한다. 종단간 암호화에 의하여 서버 운영자도 데이터 내용을 열람할 수 없다.

**제2 효과 (비동시 온라인 동기화):** 종래의 P2P 방식과 달리, 두 기기가 동시에 온라인 상태가 아니더라도 동기화가 가능하다. 로컬 델타 저널에 의하여 소정의 보관 기간 내에 상대 기기가 온라인으로 복귀하면 누락된 데이터가 자동으로 재전송된다.

**제3 효과 (순서 보장):** 시퀀스 넘버, 순서 대기 버퍼, 및 갭 탐지 메커니즘에 의하여, 네트워크 지연으로 인한 전송 순서 역전이 발생하더라도 데이터가 올바른 순서로 적용된다.

**제4 효과 (멱등성 및 중복 방지):** 기기 식별자와 시퀀스 넘버의 결합에 의한 전역적 고유 식별과, 버전 벡터에 의한 수신 이력 관리에 의하여, 동일한 델타가 중복 적용되는 것이 방지된다.

**제5 효과 (장기 오프라인 복구):** 소정의 보관 기간을 초과하여 오프라인이었던 기기에 대해서도, 매니페스트 비교 기반 수동 전체 동기화에 의하여 완전한 데이터 일관성의 복원이 가능하다.

**제6 효과 (서버 비용 절감):** 서버가 데이터를 영구 저장하지 않으므로, 사용자 수 증가에 따른 저장 비용이 발생하지 않는다. 서버의 역할은 일시적 중계와 WebSocket 시그널링으로 한정된다.

---

## [발명을 실시하기 위한 구체적인 내용]

### 실시예 1: 시스템 전체 구성

도 1은 본 발명의 일 실시예에 따른 다중 기기 간 메모리 동기화 시스템의 전체 구성을 나타내는 블록도이다.

```
┌──────────────────────────────────────────────────────────────┐
│                        시스템 전체 구성                        │
│                                                              │
│  ┌─────────────┐     ┌──────────────────┐    ┌─────────────┐ │
│  │   기기 A     │     │     서버 (릴레이)   │    │   기기 B     │ │
│  │             │     │                  │    │             │ │
│  │ ┌─────────┐ │     │ ┌──────────────┐ │    │ ┌─────────┐ │ │
│  │ │암호화    │ │     │ │ 임시 데이터   │ │    │ │복호화    │ │ │
│  │ │엔진     │ │────▶│ │ 저장소       │ │───▶│ │엔진     │ │ │
│  │ │(AES-256)│ │     │ │ (TTL 5분)    │ │    │ │(AES-256)│ │ │
│  │ └─────────┘ │     │ └──────────────┘ │    │ └─────────┘ │ │
│  │             │     │                  │    │             │ │
│  │ ┌─────────┐ │     │ ┌──────────────┐ │    │ ┌─────────┐ │ │
│  │ │델타     │ │◀───▶│ │ WebSocket    │ │◀──▶│ │델타     │ │ │
│  │ │저널     │ │     │ │ 브로드캐스트  │ │    │ │저널     │ │ │
│  │ │(30일)   │ │     │ │ (비저장)      │ │    │ │(30일)   │ │ │
│  │ └─────────┘ │     │ └──────────────┘ │    │ └─────────┘ │ │
│  │             │     │                  │    │             │ │
│  │ ┌─────────┐ │     │                  │    │ ┌─────────┐ │ │
│  │ │버전     │ │     │                  │    │ │버전     │ │ │
│  │ │벡터     │ │     │                  │    │ │벡터     │ │ │
│  │ └─────────┘ │     │                  │    │ └─────────┘ │ │
│  │             │     │                  │    │             │ │
│  │ ┌─────────┐ │     │                  │    │ ┌─────────┐ │ │
│  │ │순서대기  │ │     │                  │    │ │순서대기  │ │ │
│  │ │버퍼     │ │     │                  │    │ │버퍼     │ │ │
│  │ └─────────┘ │     │                  │    │ └─────────┘ │ │
│  └─────────────┘     └──────────────────┘    └─────────────┘ │
└──────────────────────────────────────────────────────────────┘
```

본 시스템은 복수의 사용자 기기(100a, 100b, ..., 100n)와 릴레이 서버(200)를 포함한다.

각 사용자 기기(100)는 암호화 엔진(110), 델타 저널(120), 버전 벡터 관리부(130), 순서 대기 버퍼(140), 및 재조정기(150)를 포함한다.

릴레이 서버(200)는 임시 데이터 저장소(210)와 WebSocket 브로드캐스트 채널(220)을 포함한다. 임시 데이터 저장소(210)는 소정의 유효기간이 경과한 데이터를 자동 삭제하는 TTL 메커니즘을 포함한다. WebSocket 브로드캐스트 채널(220)은 메시지 내용을 데이터베이스에 저장하지 않고 연결된 기기에 즉시 전달만을 수행한다.

### 실시예 2: 제1 계층 — 임시 릴레이 기반 실시간 동기화

도 2는 수신 기기가 온라인 상태인 경우의 실시간 동기화 흐름을 나타내는 시퀀스 다이어그램이다.

```
┌──────────────────────────────────────────────────────────────┐
│           제1 계층: 실시간 동기화 시퀀스 다이어그램               │
│                                                              │
│  기기 A                  서버                    기기 B        │
│    │                      │                       │          │
│    │  ① 데이터 변경 발생    │                       │          │
│    │  ② AES-256-GCM 암호화  │                       │          │
│    │  ③ 시퀀스 넘버 부여     │                       │          │
│    │  ④ 델타 저널에 보관     │                       │          │
│    │                      │                       │          │
│    ├──⑤ 업로드 ──────────▶│                       │          │
│    │  (암호문 + IV +       │                       │          │
│    │   AuthTag +           │                       │          │
│    │   TTL=5분)            │                       │          │
│    │                      │                       │          │
│    │                      ├──⑥ Realtime 통지 ──▶│          │
│    │                      │  (INSERT 이벤트)      │          │
│    │                      │                       │          │
│    │                      │◀──⑦ 다운로드 요청 ──┤          │
│    │                      │                       │          │
│    │                      ├──⑧ 암호문 전달 ────▶│          │
│    │                      │                       │          │
│    │                      │                  ⑨ 복호화       │
│    │                      │                  ⑩ 적용         │
│    │                      │                  ⑪ 버전벡터 갱신  │
│    │                      │                       │          │
│    │              ⑫ TTL 경과 후                     │          │
│    │              서버 데이터 삭제                    │          │
│    │                      │                       │          │
└──────────────────────────────────────────────────────────────┘
```

**단계 S210:** 기기 A에서 데이터 변경(예: 장기기억 추가)이 발생한다.

**단계 S220:** 기기 A의 암호화 엔진(110)이 변경 데이터를 AES-256-GCM 알고리즘으로 암호화한다. 암호화 키는 사용자의 패스프레이즈로부터 PBKDF2를 통해 파생된 키를 사용하며, 각 암호화 시 고유한 IV(초기화 벡터)를 생성한다.

**단계 S230:** 기기 A의 재조정기(150)가 해당 변경에 대하여 단조 증가하는 시퀀스 넘버를 부여한다. 시퀀스 넘버는 기기 A 내에서 고유하며, (기기 A 식별자, 시퀀스 넘버) 쌍으로 전역적 고유성이 보장된다.

**단계 S240:** 상기 암호화된 델타를 기기 A의 로컬 델타 저널(120)에 보관한다.

**단계 S250:** 암호화된 데이터, IV, 인증 태그, 기기 식별자, 시퀀스 넘버, 및 유효기간(현재 시각 + 5분)을 릴레이 서버(200)의 임시 데이터 저장소(210)에 업로드한다.

**단계 S260:** 릴레이 서버(200)가 WebSocket 실시간 채널을 통하여 기기 B에 데이터 도착을 통지한다.

**단계 S270-S280:** 기기 B가 릴레이 서버(200)로부터 암호화된 데이터를 다운로드한다.

**단계 S290:** 기기 B의 암호화 엔진(110)이 데이터를 복호화하고, 순서 검증 후 적용한다. 기기 B의 버전 벡터(130)에서 기기 A에 대한 마지막 수신 시퀀스를 갱신한다.

**단계 S2100:** 유효기간(5분) 경과 후, 릴레이 서버(200)의 임시 데이터 저장소(210)에서 해당 데이터가 자동 삭제된다.

### 실시예 3: 제2 계층 — 순서 보장 메커니즘

도 3은 네트워크 지연으로 인한 전송 순서 역전 시의 순서 보장 처리를 나타내는 도면이다.

```
┌──────────────────────────────────────────────────────────────────┐
│                제2 계층: 순서 보장 메커니즘                          │
│                                                                  │
│  기기 A 전송 순서:  seq 1 → seq 2 → seq 3 → seq 4 → seq 5        │
│                                                                  │
│  기기 B 수신 순서:  seq 1, seq 3, seq 2, seq 5, seq 4             │
│                    (네트워크 지연으로 순서 역전)                     │
│                                                                  │
│  기기 B 처리 흐름:                                                 │
│  ┌──────────────────────────────────────────────────────────────┐ │
│  │ 수신      │ 기대 시퀀스 │ 동작          │ 버전벡터 │ 순서버퍼  │ │
│  ├───────────┼───────────┼──────────────┼────────┼─────────── │ │
│  │ seq 1     │     1     │ ✅ 즉시 적용  │ A→1    │ (비어있음) │ │
│  │ seq 3     │     2     │ ⏳ 버퍼 저장  │ A→1    │ [3]       │ │
│  │ seq 2     │     2     │ ✅ 즉시 적용  │ A→2    │ [3]       │ │
│  │           │           │ ✅ 버퍼 플러시 │ A→3    │ (비어있음) │ │
│  │ seq 5     │     4     │ ⏳ 버퍼 저장  │ A→3    │ [5]       │ │
│  │ seq 4     │     4     │ ✅ 즉시 적용  │ A→4    │ [5]       │ │
│  │           │           │ ✅ 버퍼 플러시 │ A→5    │ (비어있음) │ │
│  └──────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  최종 적용 순서: seq 1 → seq 2 → seq 3 → seq 4 → seq 5 ✅        │
└──────────────────────────────────────────────────────────────────┘
```

**단계 S310:** 수신 기기의 재조정기(150)는 수신한 델타의 시퀀스 넘버(Sn)와 버전 벡터(130)에 기록된 해당 송신 기기의 마지막 수신 시퀀스(Lv)를 비교한다.

**단계 S320:** Sn ≤ Lv인 경우 (이미 수신된 시퀀스), 해당 델타를 무시한다. 이에 의하여 네트워크 재전송 등에 의한 중복 적용이 방지된다.

**단계 S330:** Sn = Lv + 1인 경우 (기대 시퀀스), 해당 델타를 즉시 적용하고 버전 벡터를 Lv = Sn으로 갱신한다. 이후 순서 대기 버퍼(140)에 연속된 다음 시퀀스(Sn + 1, Sn + 2, ...)가 존재하는지 검사하고, 존재하는 경우 연속적으로 적용한다(버퍼 플러시).

**단계 S340:** Sn > Lv + 1인 경우 (갭 발생), 해당 델타를 순서 대기 버퍼(140)에 시퀀스 순으로 삽입한다. 동시에 누락된 시퀀스(Lv + 1 ~ Sn - 1)에 대한 재전송 요청을 브로드캐스트 채널을 통하여 발신한다.

### 실시예 4: 제2 계층 — 오프라인 후 재연결 시 자동 재동기화

도 4는 수신 기기가 오프라인이었다가 복귀한 경우의 자동 재동기화 흐름을 나타내는 시퀀스 다이어그램이다.

```
┌──────────────────────────────────────────────────────────────────┐
│        제2 계층: 오프라인 후 재연결 자동 재동기화                     │
│                                                                  │
│  기기 A                    서버                     기기 B         │
│    │                        │                        │           │
│    │  ① seq 4, 5, 6 생성    │                        │ (오프라인) │
│    │  ② 서버에 업로드        │                        │           │
│    ├──────────────────────▶│                        │           │
│    │  ③ 델타 저널에 보관     │                        │           │
│    │                        │  ④ TTL 5분 경과         │           │
│    │                        │     서버 데이터 삭제 💨  │           │
│    │                        │                        │           │
│    │                        │             ⑤ 기기 B 온라인 복귀    │
│    │                        │                        │           │
│    │                        │◀─ ⑥ sync_request ─────┤           │
│    │◀─── broadcast ────────│  버전벡터: {A→3}        │           │
│    │                        │                        │           │
│    │  ⑦ 저널 검색:          │                        │           │
│    │  B가 A의 seq 3까지      │                        │           │
│    │  받았으므로             │                        │           │
│    │  seq 4,5,6 누락         │                        │           │
│    │                        │                        │           │
│    ├── ⑧ sync_response ──▶│── broadcast 전달 ─────▶│           │
│    │  (seq 4, 5, 6 재전송)   │  (DB 저장 없음)        │           │
│    │                        │                        │           │
│    │                        │                   ⑨ 수신 + 적용    │
│    │                        │                   ⑩ 버전벡터 갱신   │
│    │                        │                      {A→6}        │
│    │                        │                        │           │
│    │                        │◀──⑪ delta_ack ────────┤           │
│    │◀─── broadcast ────────│                        │           │
│    │                        │                        │           │
└──────────────────────────────────────────────────────────────────┘
```

**단계 S410:** 기기 A에서 데이터 변경(seq 4, 5, 6)이 발생한다. 기기 A는 이를 서버에 업로드하고, 동시에 로컬 델타 저널(120)에 보관한다.

**단계 S420:** 기기 B가 오프라인 상태이므로 데이터를 수신하지 못한다. 서버의 TTL 경과 후 데이터가 자동 삭제된다.

**단계 S430:** 기기 B가 온라인으로 복귀한다. 기기 B의 재조정기(150)는 브로드캐스트 채널(220) 연결 완료 시, 자신의 버전 벡터 {A→3}를 포함한 sync_request 메시지를 자동으로 브로드캐스트한다.

**단계 S440:** 기기 A의 재조정기(150)가 상기 sync_request를 수신하고, 기기 B의 버전 벡터 {A→3}과 자신의 로컬 델타 저널(120)을 비교한다. 기기 B가 기기 A의 seq 3까지만 수신하였으므로, seq 4, 5, 6이 누락 델타로 식별된다.

**단계 S450:** 기기 A가 누락 델타(seq 4, 5, 6)를 sync_response 메시지로 브로드캐스트 채널을 통하여 전송한다. 대량의 누락 델타가 있는 경우 소정의 배치 크기(예: 50개)로 분할 전송한다.

**단계 S460:** 기기 B가 수신한 델타를 시퀀스 순으로 적용하고 버전 벡터를 {A→6}으로 갱신한다.

**단계 S470:** 기기 B가 수신 확인(delta_ack) 메시지를 발신한다.

### 실시예 5: 제3 계층 — 수동 전체 동기화

도 5는 소정의 보관 기간(30일)을 초과하여 오프라인이었던 기기의 수동 전체 동기화 흐름을 나타내는 시퀀스 다이어그램이다.

```
┌──────────────────────────────────────────────────────────────────┐
│              제3 계층: 수동 전체 동기화                              │
│                                                                  │
│  기기 A (60일간 오프라인)        서버            기기 B (계속 사용)   │
│    │                            │                │               │
│    │  ① 이용자: "동기화" 버튼     │                │               │
│    │                            │                │               │
│    │  ② 내 매니페스트 생성:       │                │               │
│    │  memories: [m1,m2,m3]       │                │               │
│    │  conversations: [c1,c2]     │                │               │
│    │                            │                │               │
│    ├── ③ full_sync_request ───▶│── broadcast ─▶│               │
│    │  (내 매니페스트 포함)        │                │               │
│    │                            │                │               │
│    │                            │          ④ 상대 매니페스트 생성:  │
│    │                            │          memories: [m1~m8]      │
│    │                            │          conversations: [c1~c5] │
│    │                            │                │               │
│    │◀── broadcast ──────────── │◀─ ⑤ manifest_response ─┤       │
│    │                            │   (상대 매니페스트 포함)  │       │
│    │                            │                │               │
│    │  ⑥ 양방향 차분(diff) 계산:  │                │               │
│    │  내가 빠진 것:              │          ⑥' 상대도 diff 계산:    │
│    │   m4,m5,m6,m7,m8           │          상대가 빠진 것:         │
│    │   c3,c4,c5                 │           (이 경우 없음)         │
│    │  상대가 빠진 것:            │                │               │
│    │   (이 경우 없음)            │                │               │
│    │                            │                │               │
│    │                            │◀─ ⑦ full_sync_data ────┤       │
│    │◀── broadcast(m4) ─────────│  (m4 암호문)     │               │
│    │◀── broadcast(m5) ─────────│◀─ (m5 암호문) ──┤               │
│    │◀── broadcast(m6) ─────────│◀─ (m6 암호문) ──┤               │
│    │◀── broadcast(m7) ─────────│◀─ (m7 암호문) ──┤               │
│    │◀── broadcast(m8) ─────────│◀─ (m8 암호문) ──┤               │
│    │◀── broadcast(c3) ─────────│◀─ (c3 암호문) ──┤               │
│    │◀── broadcast(c4) ─────────│◀─ (c4 암호문) ──┤               │
│    │◀── broadcast(c5) ─────────│◀─ (c5 암호문) ──┤               │
│    │                            │                │               │
│    │  ⑧ 각 엔티티 복호화 + 저장  │                │               │
│    │  진행 상황: 1/8, 2/8, ...   │                │               │
│    │                            │                │               │
│    │                            │◀─ ⑨ full_sync_complete ┤       │
│    │◀── broadcast ──────────── │  (sentCount: 8)  │               │
│    │                            │                │               │
│    │  ⑩ 동기화 완료! ✅          │                │               │
│    │                            │                │               │
└──────────────────────────────────────────────────────────────────┘
```

**단계 S510:** 사용자가 기기 A에서 수동 동기화를 요청한다 (예: UI의 "동기화" 버튼 탭).

**단계 S520:** 기기 A의 재조정기(150)가 자신이 보유한 모든 엔티티의 식별자 목록(매니페스트)을 생성한다. 매니페스트는 장기기억 청크 ID 목록, 대화 세션 ID 목록, 설정 키 목록을 포함한다.

**단계 S530:** 기기 A가 자신의 매니페스트를 포함한 full_sync_request 메시지를 브로드캐스트 채널을 통하여 전송한다.

**단계 S540:** 기기 B의 재조정기(150)가 상기 요청을 수신하고, 자신의 매니페스트를 생성하여 full_sync_manifest_response 메시지로 응답한다.

**단계 S550:** 양측 기기가 수신한 상대 매니페스트와 자신의 매니페스트를 비교한다. 비교는 엔티티 식별자 집합에 대한 차집합(set difference) 연산으로 수행된다. 이에 의하여 한쪽에만 존재하는 엔티티가 식별된다.

**단계 S560:** 각 기기가 자신이 보유하고 상대에게 누락된 엔티티를 full_sync_data 메시지로 하나씩 전송한다. 각 엔티티는 종단간 암호화된 상태로 전송된다.

**단계 S570:** 수신 기기가 각 엔티티를 복호화하고 로컬 저장소에 저장한다. 수신 진행 상황이 사용자에게 표시된다.

**단계 S580:** 모든 누락 엔티티의 전송이 완료되면, 전송 측이 full_sync_complete 메시지를 발신하여 수신 측에 완료를 통지한다.

### 실시예 6: 3단계 계층 통합 동작

도 6은 본 발명의 3단계 계층이 통합적으로 동작하는 판단 흐름을 나타내는 플로우차트이다.

```
┌──────────────────────────────────────────────────────────────┐
│                 3단계 계층 통합 판단 흐름                       │
│                                                              │
│                    ┌───────────┐                             │
│                    │ 동기화    │                              │
│                    │ 이벤트    │                              │
│                    │ 발생      │                              │
│                    └─────┬─────┘                             │
│                          │                                   │
│                          ▼                                   │
│                 ┌────────────────┐                            │
│                 │ 상대 기기가     │                            │
│            ┌─── │ 온라인인가?    │───┐                        │
│            │    └────────────────┘   │                        │
│          예 │                       아니오                     │
│            ▼                         ▼                        │
│   ┌─────────────┐          ┌──────────────┐                  │
│   │ 제1 계층     │          │ 임시 릴레이에  │                  │
│   │ 실시간 릴레이 │          │ 업로드       │                   │
│   │ (즉시 전달)  │          │ (TTL 5분)    │                   │
│   └──────┬──────┘          │ + 로컬 저널   │                   │
│          │                 │   저장        │                   │
│          ▼                 └───────┬──────┘                   │
│      완료 ✅                        │                          │
│                                    ▼                          │
│                          ┌──────────────┐                     │
│                          │ 상대가 30일   │                     │
│                     ┌─── │ 이내 복귀?    │───┐                 │
│                     │    └──────────────┘   │                 │
│                   예 │                    아니오                │
│                     ▼                       ▼                 │
│            ┌─────────────┐         ┌──────────────┐           │
│            │ 제2 계층     │         │ 제3 계층      │           │
│            │ 자동 재전송  │         │ 수동 전체     │            │
│            │ (저널→재릴레이)│         │ 동기화       │           │
│            └──────┬──────┘         │ (매니페스트   │            │
│                   │                │  비교)        │            │
│                   ▼                └───────┬──────┘            │
│               완료 ✅                       │                   │
│                                            ▼                   │
│                                        완료 ✅                  │
└──────────────────────────────────────────────────────────────┘
```

상기 3단계 계층은 각각이 이전 계층의 한계를 보완하는 계층적 구조를 형성하며, 이에 의하여 서버에 데이터를 영구 저장하지 않으면서도 다양한 오프라인 시나리오에 대응하는 완전한 동기화 솔루션이 달성된다.

### 실시예 7: 데이터 구조

이하, 본 발명의 실시에 사용되는 주요 데이터 구조를 설명한다.

#### 7-1. 동기화 델타 (SyncDelta)

```
SyncDelta {
  id: string                  // 전역 고유 식별자 (기기ID-시퀀스-타임스탬프)
  sourceDeviceId: string      // 생성 기기 식별자
  seq: number                 // 기기 내 단조 증가 시퀀스 넘버
  deltaType: "add" | "update" | "delete"  // 변경 유형
  entityType: "memory_chunk" | "conversation" | "setting"  // 대상 엔티티 유형
  encryptedPayload: string    // AES-256-GCM 암호화된 데이터
  iv: string                  // 초기화 벡터
  authTag: string             // 인증 태그
  createdAt: string           // 생성 시각 (ISO 8601)
}
```

#### 7-2. 버전 벡터 (Version Vector)

```
VersionVector = {
  [deviceId: string]: number  // 각 기기로부터 마지막 수신한 시퀀스 넘버
}

예시:
{
  "device-A": 42,   // 기기 A로부터 seq 42까지 수신 완료
  "device-B": 17,   // 기기 B로부터 seq 17까지 수신 완료
  "device-C": 8     // 기기 C로부터 seq 8까지 수신 완료
}
```

#### 7-3. 전체 동기화 매니페스트 (FullSyncManifest)

```
FullSyncManifest {
  memoryChunkIds: string[]     // 장기기억 청크 ID 목록
  conversationIds: string[]    // 대화 세션 ID 목록
  settingKeys: string[]        // 설정 키 목록
  generatedAt: string          // 생성 시각 (ISO 8601)
}
```

#### 7-4. 브로드캐스트 메시지 유형

```
BroadcastMessage =
  // 자동 재동기화용
  | { type: "sync_request",  fromDeviceId, versionVector }
  | { type: "sync_response", fromDeviceId, deltas[] }
  | { type: "delta_ack",     fromDeviceId, sourceDeviceId, lastSeq }
  // 수동 전체 동기화용
  | { type: "full_sync_request",           fromDeviceId, manifest }
  | { type: "full_sync_manifest_response", fromDeviceId, manifest }
  | { type: "full_sync_data",    fromDeviceId, entityType, entityId, encryptedPayload, iv, authTag }
  | { type: "full_sync_complete", fromDeviceId, sentCount }
```

#### 7-5. 재조정기 상태 (ReconcilerState) — 영속화 대상

```
ReconcilerState {
  localSeq: number             // 현재 시퀀스 넘버
  versionVector: VersionVector // 버전 벡터
  journal: SyncDelta[]         // 로컬 델타 저널
  exportedAt: string           // 상태 내보내기 시각
}
```

---

## [청구범위]

### 청구항 1 (독립항)

서버에 사용자 데이터를 영구적으로 저장하지 않으면서 복수의 사용자 기기 간에 데이터를 동기화하는 방법으로서,

(a) 송신 기기가 동기화 대상 데이터를 종단간 암호화하는 단계;

(b) 상기 암호화된 데이터에 소정의 유효기간을 부여하여 릴레이 서버에 업로드하되, 상기 릴레이 서버는 상기 유효기간 경과 후 상기 데이터를 자동 삭제하는 단계;

(c) 상기 송신 기기가 상기 암호화된 데이터를 단조 증가하는 시퀀스 넘버와 함께 로컬 델타 저널에 소정의 보관 기간 동안 보관하는 단계;

(d) 수신 기기가 온라인으로 복귀한 때에, 상기 수신 기기의 버전 벡터를 포함하는 동기화 요청을 데이터베이스 저장을 수반하지 않는 브로드캐스트 채널을 통하여 발신하는 단계;

(e) 상기 동기화 요청을 수신한 온라인 기기가, 상기 수신 기기의 버전 벡터와 자신의 로컬 델타 저널을 비교하여 누락 델타를 식별하고, 상기 누락 델타를 상기 브로드캐스트 채널을 통하여 재전송하는 단계; 및

(f) 상기 수신 기기가 수신한 델타를 시퀀스 넘버 순서대로 적용하는 단계

를 포함하는 것을 특징으로 하는, 다중 기기 간 데이터 동기화 방법.

### 청구항 2 (종속항)

제1항에 있어서,

상기 (f) 단계는,

수신한 델타의 시퀀스 넘버가 기대 시퀀스(버전 벡터의 마지막 수신 시퀀스 + 1)와 일치하는 경우 즉시 적용하는 단계;

기대 시퀀스보다 큰 시퀀스의 델타가 수신된 경우 순서 대기 버퍼에 보관하는 단계; 및

상기 순서 대기 버퍼에 연속된 시퀀스의 델타가 축적된 경우 일괄 적용하는 단계

를 포함하는 것을 특징으로 하는, 다중 기기 간 데이터 동기화 방법.

### 청구항 3 (종속항)

제1항에 있어서,

기대 시퀀스 이하의 시퀀스를 가진 델타가 수신된 경우, 이미 수신된 중복 데이터로 판단하여 무시하는 단계

를 더 포함하는 것을 특징으로 하는, 다중 기기 간 데이터 동기화 방법.

### 청구항 4 (종속항)

제1항에 있어서,

상기 소정의 보관 기간을 초과하여 오프라인이었던 기기에 대하여, 사용자의 수동 요청에 의한 전체 동기화를 수행하는 단계를 더 포함하되,

상기 전체 동기화는,

요청 기기가 자신이 보유한 엔티티 식별자 목록인 매니페스트를 생성하여 브로드캐스트 채널로 전송하는 단계;

응답 기기가 자신의 매니페스트를 생성하여 응답하는 단계;

양측이 상대 매니페스트와 자신의 매니페스트를 비교하여, 각각이 보유하고 상대방에게 누락된 엔티티를 식별하는 단계; 및

식별된 누락 엔티티를 종단간 암호화된 상태로 브로드캐스트 채널을 통하여 상호 전송하는 단계

를 포함하는 것을 특징으로 하는, 다중 기기 간 데이터 동기화 방법.

### 청구항 5 (종속항)

제4항에 있어서,

상기 매니페스트의 비교는 엔티티 식별자 집합에 대한 차집합 연산으로 수행되어, 양측이 공통으로 보유한 엔티티의 재전송 없이 누락된 엔티티만을 선택적으로 전송하는 것을 특징으로 하는, 다중 기기 간 데이터 동기화 방법.

### 청구항 6 (종속항)

제4항에 있어서,

상기 전체 동기화는 양방향으로 수행되어, 요청 기기와 응답 기기 각각이 상대방에게 누락된 엔티티를 동시에 전송하는 것을 특징으로 하는, 다중 기기 간 데이터 동기화 방법.

### 청구항 7 (종속항)

제1항에 있어서,

각 기기는 애플리케이션 종료 시 현재의 시퀀스 넘버, 버전 벡터, 및 델타 저널을 로컬 영속 저장소에 저장하고, 애플리케이션 재시작 시 상기 저장된 상태를 복원하여 동기화의 연속성을 보장하는 단계

를 더 포함하는 것을 특징으로 하는, 다중 기기 간 데이터 동기화 방법.

### 청구항 8 (종속항)

제1항에 있어서,

상기 종단간 암호화는 AES-256-GCM 알고리즘을 사용하며, 암호화 키는 사용자의 패스프레이즈로부터 PBKDF2 키 유도 함수를 통하여 파생되고, 각 암호화 작업에 고유한 초기화 벡터(IV)가 사용되는 것을 특징으로 하는, 다중 기기 간 데이터 동기화 방법.

### 청구항 9 (종속항)

제1항에 있어서,

상기 브로드캐스트 채널은 WebSocket 기반의 실시간 통신 채널로서, 전달되는 메시지 내용이 서버의 데이터베이스에 저장되지 않는 것을 특징으로 하는, 다중 기기 간 데이터 동기화 방법.

### 청구항 10 (종속항)

제1항에 있어서,

상기 (e) 단계에서 누락 델타의 수가 소정의 배치 크기를 초과하는 경우, 상기 누락 델타를 상기 배치 크기 단위로 분할하여 순차적으로 전송하는 것을 특징으로 하는, 다중 기기 간 데이터 동기화 방법.

### 청구항 11 (독립항 — 시스템)

서버에 사용자 데이터를 영구적으로 저장하지 않으면서 복수의 사용자 기기 간에 데이터를 동기화하는 시스템으로서,

각 사용자 기기에 설치되는 동기화 클라이언트 모듈; 및

릴레이 서버를 포함하되,

상기 동기화 클라이언트 모듈은,

데이터를 종단간 암호화 및 복호화하는 암호화 엔진;

자신이 생성한 각 데이터 변경(델타)에 단조 증가하는 시퀀스 넘버를 부여하고, 다른 기기로부터 수신한 마지막 시퀀스 넘버를 기기별로 추적하는 버전 벡터를 관리하는 재조정기;

상기 암호화된 델타를 소정의 보관 기간 동안 보관하는 로컬 델타 저널; 및

수신한 델타의 시퀀스 넘버가 기대 순서와 불일치하는 경우 해당 델타를 임시 보관하는 순서 대기 버퍼

를 포함하고,

상기 릴레이 서버는,

소정의 유효기간이 경과한 데이터를 자동 삭제하는 임시 데이터 저장소; 및

메시지 내용을 데이터베이스에 저장하지 않고 연결된 기기에 전달하는 브로드캐스트 채널

을 포함하며,

상기 동기화 클라이언트 모듈은 상대 기기가 상기 유효기간 내에 데이터를 수신하지 못한 경우, 상기 로컬 델타 저널로부터 누락 데이터를 식별하여 상기 브로드캐스트 채널을 통하여 재전송하는 것을 특징으로 하는, 다중 기기 간 데이터 동기화 시스템.

### 청구항 12 (종속항)

제11항에 있어서,

상기 재조정기는,

소정의 보관 기간을 초과하여 오프라인이었던 기기로부터 수동 전체 동기화 요청을 수신하는 경우, 양측 기기의 엔티티 식별자 목록(매니페스트)을 비교하여 누락 엔티티를 식별하고, 식별된 누락 엔티티를 종단간 암호화 상태로 상호 전송하는 전체 동기화 수행부

를 더 포함하는 것을 특징으로 하는, 다중 기기 간 데이터 동기화 시스템.

### 청구항 13 (독립항 — 컴퓨터 판독 가능 기록 매체)

제1항 내지 제10항 중 어느 한 항의 방법을 컴퓨터에 실행시키기 위한 프로그램이 기록된 컴퓨터 판독 가능 기록 매체.

---

## [요약서]

### [요약]

본 발명은 서버에 사용자 데이터를 영구적으로 저장하지 않으면서 복수의 사용자 기기 간에 종단간 암호화된 데이터를 동기화하는 시스템 및 방법에 관한 것이다.

본 발명은 3단계 계층적 동기화 구조를 제공한다. 제1 계층은 서버를 소정의 유효기간(TTL)을 가진 임시 릴레이로 활용하여 실시간 동기화를 수행한다. 제2 계층은 각 기기가 로컬에 보관하는 델타 저널과 버전 벡터를 이용하여, 오프라인이었던 기기가 복귀 시 누락 데이터를 데이터베이스 저장 없는 브로드캐스트 채널을 통하여 자동 재전송한다. 시퀀스 넘버와 순서 대기 버퍼에 의하여 전송 순서 역전 시에도 올바른 순서가 보장된다. 제3 계층은 소정의 보관 기간을 초과한 장기 오프라인 기기에 대하여, 엔티티 식별자 목록(매니페스트)의 양방향 비교에 기반한 수동 전체 동기화를 제공한다.

### [대표도]

도 6

### [대표도의 도면부호의 설명]

- 100: 사용자 기기
- 110: 암호화 엔진
- 120: 로컬 델타 저널
- 130: 버전 벡터 관리부
- 140: 순서 대기 버퍼
- 150: 재조정기
- 200: 릴레이 서버
- 210: 임시 데이터 저장소
- 220: WebSocket 브로드캐스트 채널
